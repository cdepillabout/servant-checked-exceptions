{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE UndecidableInstances #-}

{- |
Module      :  Servant.Checked.Exceptions.Internal.Servant.API

Copyright   :  Dennis Gosnell 2017
License     :  BSD3

Maintainer  :  Dennis Gosnell (cdep.illabout@gmail.com)
Stability   :  experimental
Portability :  unknown

This module defines the 'Throws' and 'Throwing' types, and their
envelope-polymorphic variants 'Throws\'' and 'Throwing\''
-}

module Servant.Checked.Exceptions.Internal.Servant.API where

import GHC.Exts (Constraint)
import Network.HTTP.Types (Status)
import Servant.API ((:>))
import Data.Functor.Identity (Identity (Identity))
import Data.WorldPeace (OpenUnion, Union (That, This))

import Servant.Checked.Exceptions.Internal.Util (Snoc)
import Servant.Checked.Exceptions.Internal.Envelope (Envelope, envelope, toSuccEnvelope, toErrEnvelope)

-- | 'Throws' is used in Servant API definitions and signifies that an API will
-- throw the given error.
--
-- Here is an example of how to create an API that potentially returns a
-- 'String' as an error, or an 'Int' on success:
--
-- >>> import Servant.API (Get, JSON, (:>))
-- >>> type API = Throws String :> Get '[JSON] Int
--
-- @Throws@ is a specialized case for @Throws'@, that accepts an additional
-- envelope parameter @envel@. For @Throws@ this is @Envelope@.
-- All combinators with a prime are polymorphic in the envelope.
-- For an example of a custom envelope, take a look at 'Servant.Checked.Exceptions.Internal.FlatEnvelope'
type Throws (e :: *) = Throws' Envelope e
data Throws' (env :: [*] -> * -> *) (e :: *)

-- | 'NoThrow' is used to indicate that an API will not throw an error, but
-- that it will still return a response wrapped in a
-- 'Servant.Checked.Exceptions.Internal.Envelope.Envelope'.
--
-- ==== __Examples__
--
-- Create an API using 'NoThrow':
--
-- >>> import Servant.API (Get, JSON, (:>))
-- >>> type API = NoThrow :> Get '[JSON] Int
--
-- A servant-server handler for this type would look like the following:
--
-- @
--   apiHandler :: 'Servant.Handler' ('Servant.Checked.Exceptions.Internal.Envelope.Envelope' \'[] Int)
--   apiHandler = 'Servant.Checked.Exceptions.Internal.Envelope.pureSuccEnvelope' 3
-- @
data NoThrow' (env :: [*] -> * -> *)
type NoThrow = NoThrow' Envelope

-- | This is used internally and should not be used by end-users.
data Throwing' (env :: [*] -> * -> *) (e :: [*])
type Throwing (e :: [*]) = Throwing' Envelope e


-- | Used by the 'HasServer' and 'HasClient' instances for
-- @'Throwing' es ':>' api ':>' apis@ to detect @'Throwing' es@ followed
-- immediately by @'Throws' e@.
type family ThrowingNonterminal api where
  ThrowingNonterminal (Throwing' env es :> Throws' env e :> api) =
    Throwing' env (Snoc es e) :> api
  ThrowingNonterminal (Throwing' env es :> c :> api) =
    c :> Throwing' env es :> api


-- | Note that clients generated by @servant-client@ currently don't handle
-- status codes outside the @2XX@ range correctly.
-- Take a look at the README for more details.
class ErrStatus e where
  toErrStatus :: e -> Status

type family AllErrStatus (es :: [k]) :: Constraint where
  AllErrStatus '[] = ()
  AllErrStatus (a ': as) = (ErrStatus a, AllErrStatus as)

-- | Get the HTTP status from an @envelope@.
class EnvelopeStatus es (envel :: [*] -> * -> *) where
  getEnvelopeStatus :: envel es a -> Status -> Status

instance AllErrStatus es => EnvelopeStatus es Envelope where
  getEnvelopeStatus envel successStatus = envelope getErrStatus (const successStatus) envel

-- | Get the HTTP status from an @OpenUnion es@, used by @Envelope@.
getErrStatus :: AllErrStatus es => OpenUnion es -> Status
getErrStatus (This (Identity e)) = toErrStatus e
getErrStatus (That es)           = getErrStatus es

-- | Create an envelope from success or error values.
class MkEnvelope (envel :: [*] -> * -> *) where
  mkSuccEnvelope :: a -> envel es a
  mkErrEnvelope :: e -> envel '[e] a

instance MkEnvelope Envelope where
  mkSuccEnvelope = toSuccEnvelope
  mkErrEnvelope = toErrEnvelope

-- $setup
-- >>> :set -XDataKinds
-- >>> :set -XTypeOperators
